// Essential Beta Monitoring Setup for DependencyWarden

// 1. Enhanced Error Tracking and Alerting
class ProductionMonitor {
  constructor() {
    this.metrics = {
      requestCount: 0,
      errorCount: 0,
      responseTimeSum: 0,
      slowQueries: 0,
      memoryAlerts: 0
    };
    
    this.startTime = Date.now();
    this.alertThresholds = {
      errorRate: 0.05, // 5% error rate threshold
      responseTime: 2000, // 2 second response time
      memoryUsage: 0.85 // 85% memory usage
    };
  }

  // Track all API requests
  trackRequest(endpoint, responseTime, statusCode) {
    this.metrics.requestCount++;
    this.metrics.responseTimeSum += responseTime;
    
    if (statusCode >= 400) {
      this.metrics.errorCount++;
      this.logError(`HTTP ${statusCode} on ${endpoint}`, { responseTime, statusCode });
    }
    
    if (responseTime > this.alertThresholds.responseTime) {
      this.metrics.slowQueries++;
      this.alertSlowResponse(endpoint, responseTime);
    }
    
    // Log performance metrics every 100 requests
    if (this.metrics.requestCount % 100 === 0) {
      this.logPerformanceMetrics();
    }
  }

  // Critical error logging
  logError(message, details = {}) {
    const errorLog = {
      timestamp: new Date().toISOString(),
      message,
      details,
      metrics: this.getCurrentMetrics(),
      userCount: this.getActiveUserCount()
    };
    
    console.error('ðŸš¨ PRODUCTION ERROR:', JSON.stringify(errorLog, null, 2));
    
    // In production, send to external service (Sentry, etc.)
    this.sendToErrorTracking(errorLog);
  }

  // Performance metrics logging
  logPerformanceMetrics() {
    const avgResponseTime = this.metrics.responseTimeSum / this.metrics.requestCount;
    const errorRate = this.metrics.errorCount / this.metrics.requestCount;
    const uptime = (Date.now() - this.startTime) / 1000 / 60; // minutes
    
    const performanceReport = {
      timestamp: new Date().toISOString(),
      uptime: `${uptime.toFixed(2)} minutes`,
      totalRequests: this.metrics.requestCount,
      averageResponseTime: `${avgResponseTime.toFixed(2)}ms`,
      errorRate: `${(errorRate * 100).toFixed(2)}%`,
      slowQueries: this.metrics.slowQueries,
      memoryUsage: this.getMemoryUsage()
    };
    
    console.log('ðŸ“Š PERFORMANCE METRICS:', JSON.stringify(performanceReport, null, 2));
    
    // Alert if thresholds exceeded
    if (errorRate > this.alertThresholds.errorRate) {
      this.alertHighErrorRate(errorRate);
    }
  }

  // Memory monitoring
  getMemoryUsage() {
    const used = process.memoryUsage();
    return {
      rss: `${Math.round(used.rss / 1024 / 1024)} MB`,
      heapTotal: `${Math.round(used.heapTotal / 1024 / 1024)} MB`,
      heapUsed: `${Math.round(used.heapUsed / 1024 / 1024)} MB`,
      external: `${Math.round(used.external / 1024 / 1024)} MB`
    };
  }

  // Database connection monitoring
  monitorDatabaseHealth() {
    // Check database connection pool
    const poolStats = {
      totalConnections: global.dbPool?.totalCount || 0,
      idleConnections: global.dbPool?.idleCount || 0,
      waitingClients: global.dbPool?.waitingCount || 0
    };
    
    if (poolStats.waitingClients > 5) {
      this.logError('Database connection pool exhaustion warning', poolStats);
    }
    
    return poolStats;
  }

  // User activity tracking
  getActiveUserCount() {
    // Track active WebSocket connections or recent API calls
    return global.activeUsers?.size || 0;
  }

  // Alert functions
  alertSlowResponse(endpoint, responseTime) {
    console.warn(`âš ï¸  SLOW RESPONSE: ${endpoint} took ${responseTime}ms`);
  }

  alertHighErrorRate(errorRate) {
    console.error(`ðŸš¨ HIGH ERROR RATE: ${(errorRate * 100).toFixed(2)}% exceeds threshold`);
  }

  // External service integration
  sendToErrorTracking(errorLog) {
    // In production, integrate with Sentry, LogRocket, etc.
    // For now, we'll just ensure it's logged properly
    if (process.env.NODE_ENV === 'production') {
      // Example: Sentry.captureException(new Error(errorLog.message));
    }
  }

  // Generate daily reports
  generateDailyReport() {
    const report = {
      date: new Date().toISOString().split('T')[0],
      totalRequests: this.metrics.requestCount,
      totalErrors: this.metrics.errorCount,
      averageResponseTime: this.metrics.responseTimeSum / this.metrics.requestCount,
      uptime: (Date.now() - this.startTime) / 1000 / 60 / 60, // hours
      peakUsers: this.getActiveUserCount(),
      databaseHealth: this.monitorDatabaseHealth()
    };
    
    console.log('ðŸ“ˆ DAILY REPORT:', JSON.stringify(report, null, 2));
    return report;
  }

  getCurrentMetrics() {
    return { ...this.metrics };
  }
}

// 2. Express.js Middleware for Request Tracking
function createMonitoringMiddleware(monitor) {
  return (req, res, next) => {
    const startTime = Date.now();
    
    // Track user sessions
    if (req.user) {
      if (!global.activeUsers) global.activeUsers = new Set();
      global.activeUsers.add(req.user.id);
    }
    
    res.on('finish', () => {
      const responseTime = Date.now() - startTime;
      monitor.trackRequest(req.path, responseTime, res.statusCode);
    });
    
    next();
  };
}

// 3. Database Query Monitoring
function createDatabaseMonitor() {
  return {
    // Wrap database queries with monitoring
    monitorQuery: async (queryFn, queryName) => {
      const startTime = Date.now();
      try {
        const result = await queryFn();
        const duration = Date.now() - startTime;
        
        if (duration > 1000) { // Log slow queries
          console.warn(`ðŸŒ SLOW QUERY: ${queryName} took ${duration}ms`);
        }
        
        return result;
      } catch (error) {
        console.error(`ðŸ’¥ DATABASE ERROR in ${queryName}:`, error.message);
        throw error;
      }
    }
  };
}

// 4. Health Check Endpoint Enhancement
function createHealthCheck(monitor) {
  return async (req, res) => {
    try {
      const health = {
        status: 'healthy',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        memory: monitor.getMemoryUsage(),
        database: monitor.monitorDatabaseHealth(),
        metrics: monitor.getCurrentMetrics(),
        version: process.env.npm_package_version || '1.0.0'
      };
      
      // Test database connectivity
      try {
        await global.dbPool.query('SELECT 1');
        health.database.status = 'connected';
      } catch (error) {
        health.database.status = 'disconnected';
        health.status = 'degraded';
      }
      
      const statusCode = health.status === 'healthy' ? 200 : 503;
      res.status(statusCode).json(health);
      
    } catch (error) {
      monitor.logError('Health check failed', { error: error.message });
      res.status(503).json({
        status: 'unhealthy',
        error: error.message,
        timestamp: new Date().toISOString()
      });
    }
  };
}

// 5. Implementation Example
// Add this to your server.js or main application file:

/*
const monitor = new ProductionMonitor();
const dbMonitor = createDatabaseMonitor();

// Add monitoring middleware
app.use(createMonitoringMiddleware(monitor));

// Enhanced health check
app.get('/healthz', createHealthCheck(monitor));

// Monitor critical endpoints
app.post('/api/security-copilot/chat', async (req, res) => {
  try {
    const result = await dbMonitor.monitorQuery(
      () => handleSecurityCopilotChat(req, res),
      'security-copilot-chat'
    );
    res.json(result);
  } catch (error) {
    monitor.logError('Security copilot chat failed', { 
      userId: req.user?.id, 
      error: error.message 
    });
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Schedule daily reports
setInterval(() => {
  monitor.generateDailyReport();
}, 24 * 60 * 60 * 1000); // Every 24 hours

// Graceful shutdown monitoring
process.on('SIGTERM', () => {
  console.log('ðŸ›‘ GRACEFUL SHUTDOWN: Generating final report...');
  monitor.generateDailyReport();
  process.exit(0);
});
*/

module.exports = {
  ProductionMonitor,
  createMonitoringMiddleware,
  createDatabaseMonitor,
  createHealthCheck
};