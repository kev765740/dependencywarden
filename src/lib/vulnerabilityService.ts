import { useAsyncData } from '@/hooks/use-async-data';

interface VulnerabilitySource {
  id: string;
  name: string;
  url: string;
  description: string;
}

interface CVSS {
  version: string;
  vectorString: string;
  baseScore: number;
  baseSeverity: 'NONE' | 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
}

export interface Vulnerability {
  id: string;
  source: VulnerabilitySource;
  title: string;
  description: string;
  cvss: CVSS;
  affected: {
    package: string;
    ecosystem: string;
    versions: string[];
  };
  published: string;
  updated: string;
  references: string[];
  fixes: string[];
}

interface ScanResult {
  id: string;
  timestamp: string;
  repositoryId: string;
  vulnerabilities: Vulnerability[];
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  metadata: {
    duration: number;
    packagesScanned: number;
    sourcesChecked: string[];
  };
}

class VulnerabilityService {
  private readonly NVD_API_KEY = import.meta.env.VITE_NVD_API_KEY;
  private readonly GITHUB_TOKEN = import.meta.env.VITE_GITHUB_TOKEN;
  private readonly API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'https://api.dependencywarden.com';

  private sources: VulnerabilitySource[] = [
    {
      id: 'nvd',
      name: 'National Vulnerability Database',
      url: 'https://nvd.nist.gov/vuln',
      description: 'NIST National Vulnerability Database'
    },
    {
      id: 'ghsa',
      name: 'GitHub Security Advisory',
      url: 'https://github.com/advisories',
      description: 'GitHub Security Advisory Database'
    },
    {
      id: 'osv',
      name: 'Open Source Vulnerabilities',
      url: 'https://osv.dev',
      description: 'Open Source Vulnerabilities Database'
    }
  ];

  async scanRepository(repositoryId: string, branch: string = 'main'): Promise<ScanResult> {
    const startTime = Date.now();

    try {
      // Fetch repository dependencies
      const dependencies = await this.fetchRepositoryDependencies(repositoryId, branch);
      
      // Scan each dependency across all sources
      const vulnerabilities = await Promise.all(
        dependencies.map(dep => this.checkDependencyVulnerabilities(dep))
      );

      // Flatten and deduplicate vulnerabilities
      const uniqueVulnerabilities = this.deduplicateVulnerabilities(
        vulnerabilities.flat()
      );

      // Calculate summary
      const summary = this.calculateVulnerabilitySummary(uniqueVulnerabilities);

      return {
        id: `scan-${Date.now()}`,
        timestamp: new Date().toISOString(),
        repositoryId,
        vulnerabilities: uniqueVulnerabilities,
        summary,
        metadata: {
          duration: Date.now() - startTime,
          packagesScanned: dependencies.length,
          sourcesChecked: this.sources.map(s => s.id)
        }
      };
    } catch (error) {
      console.error('Error scanning repository:', error);
      throw new Error('Repository scan failed');
    }
  }

  private async fetchRepositoryDependencies(repositoryId: string, branch: string) {
    // TODO: Implement actual repository dependency fetching
    // This would integrate with GitHub API, GitLab API, etc.
    return [
      { name: 'react', version: '18.2.0', ecosystem: 'npm' },
      { name: 'vite', version: '5.4.19', ecosystem: 'npm' },
      // ... more dependencies
    ];
  }

  private async checkDependencyVulnerabilities(dependency: { name: string; version: string; ecosystem: string }) {
    const vulnerabilities: Vulnerability[] = [];

    // Check NVD
    try {
      const nvdVulns = await this.checkNVD(dependency);
      vulnerabilities.push(...nvdVulns);
    } catch (error) {
      console.error('NVD check failed:', error);
    }

    // Check GitHub Security Advisory
    try {
      const ghsaVulns = await this.checkGHSA(dependency);
      vulnerabilities.push(...ghsaVulns);
    } catch (error) {
      console.error('GHSA check failed:', error);
    }

    // Check OSV
    try {
      const osvVulns = await this.checkOSV(dependency);
      vulnerabilities.push(...osvVulns);
    } catch (error) {
      console.error('OSV check failed:', error);
    }

    return vulnerabilities;
  }

  private async checkNVD(dependency: { name: string; version: string; ecosystem: string }): Promise<Vulnerability[]> {
    if (!this.NVD_API_KEY) {
      console.warn('NVD API key not configured');
      return [];
    }

    // TODO: Implement actual NVD API integration
    return [];
  }

  private async checkGHSA(dependency: { name: string; version: string; ecosystem: string }): Promise<Vulnerability[]> {
    if (!this.GITHUB_TOKEN) {
      console.warn('GitHub token not configured');
      return [];
    }

    // TODO: Implement actual GitHub Security Advisory API integration
    return [];
  }

  private async checkOSV(dependency: { name: string; version: string; ecosystem: string }): Promise<Vulnerability[]> {
    // TODO: Implement actual OSV API integration
    return [];
  }

  private deduplicateVulnerabilities(vulnerabilities: Vulnerability[]): Vulnerability[] {
    const seen = new Set<string>();
    return vulnerabilities.filter(vuln => {
      const key = `${vuln.affected.package}-${vuln.id}`;
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  }

  private calculateVulnerabilitySummary(vulnerabilities: Vulnerability[]) {
    return vulnerabilities.reduce(
      (summary, vuln) => {
        summary.total++;
        switch (vuln.cvss.baseSeverity) {
          case 'CRITICAL':
            summary.critical++;
            break;
          case 'HIGH':
            summary.high++;
            break;
          case 'MEDIUM':
            summary.medium++;
            break;
          case 'LOW':
            summary.low++;
            break;
        }
        return summary;
      },
      { total: 0, critical: 0, high: 0, medium: 0, low: 0 }
    );
  }

  // Hook for React components
  useVulnerabilityScan(repositoryId: string, branch: string = 'main') {
    return useAsyncData(
      () => this.scanRepository(repositoryId, branch),
      [repositoryId, branch],
      {
        cacheKey: `vulnerability-scan-${repositoryId}-${branch}`,
        cacheTime: 5 * 60 * 1000, // 5 minutes
      }
    );
  }
}

export const vulnerabilityService = new VulnerabilityService(); 